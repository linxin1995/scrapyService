# _*_ coding: utf-8 -*_

__author__ = "linxin"

import re


def regexstu():
    """
    正则表达式学习（特殊字符说明）：
    ^ 表示以符号后面的字符开头
    . 表示这个位置可以是任意字符
    * 表示符号前面的字符可以重复任意次 .*组合就是可以是任意字符的意思 可以匹配任意长度的 只有. 表示只匹配一个字符
    $ 表示以符号前面的字符结尾
    ? 正则表达式是贪婪模式，默认从后往前匹配，加上问号表示这个字符前面的匹配规则都是非贪婪的 都是从前往后匹配
    + 表示前面的字符至少出现一次 也就是出现一次或者多次都能匹配 * + 都限定前面的字符出现的次数 * 表示可以重复多次，+ 要求必须出现至少一次
    {2} 前面的字符出现次数
    {2,} 前面字符至少出现2两次
    {2,5} 最少出现2次 最多出现5次
    | 或的关系 表示只要符合 | 前面或者后面的字符就行

    () 正则会返回符合括号中正则匹配的字符串，多个括号就会有多个group 如果是嵌套的 最外层的是group（1） 依次往里递增
    [] 中括号表示里面的字符只要满足一个就可以，



    """
    test_text1 = "lnminxin1m2313"
    reg1 = ""
    reg = "^ln.*m+3$" # ^ 以l开头 后面跟 . 任意字符 * 前面字符可以重复任意遍
    # 取出第一个n到第一个3之间的字符串 group 代表取出第几个括号里面的值 不加？会从后往前匹配 导致取值有误
    print(re.match(".*?(n.*?3).*",test_text1).group(1))

    print(re.match("linxin123|linxin","linxin123"))

    try:
        print(re.match(".*(lm+.*n$).*","aalnlllxxn").group(1))
    except:
        print("匹配失败")

    if re.match(reg,test_text1):
        print("yes")
    else:
        print("no")





if __name__ == '__main__':
    regexstu()

